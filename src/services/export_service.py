"""Content export service for various formats."""

import html
import re
from enum import Enum

from loguru import logger

from src.models.content import ContentResponse


class ExportFormat(str, Enum):
    """Supported export formats."""

    MARKDOWN = "markdown"
    HTML = "html"
    PDF = "pdf"
    JSON = "json"
    TXT = "txt"


class ExportService:
    """Service for exporting content to various formats."""

    @staticmethod
    def export(content: ContentResponse, format: ExportFormat) -> bytes:
        """Export content to the specified format.

        Args:
            content: Content response to export
            format: Target export format

        Returns:
            Exported content as bytes
        """
        if format == ExportFormat.MARKDOWN:
            return ExportService._to_markdown(content)
        elif format == ExportFormat.HTML:
            return ExportService._to_html(content)
        elif format == ExportFormat.PDF:
            return ExportService._to_pdf(content)
        elif format == ExportFormat.JSON:
            return ExportService._to_json(content)
        elif format == ExportFormat.TXT:
            return ExportService._to_txt(content)
        else:
            raise ValueError(f"Unsupported export format: {format}")

    @staticmethod
    def get_filename(content: ContentResponse, format: ExportFormat) -> str:
        """Generate a filename for the export.

        Args:
            content: Content response
            format: Export format

        Returns:
            Suggested filename
        """
        # Create a slug from the topic
        topic = content.request.topic[:50]
        slug = re.sub(r"[^\w\s-]", "", topic.lower())
        slug = re.sub(r"[-\s]+", "-", slug).strip("-")

        extensions = {
            ExportFormat.MARKDOWN: "md",
            ExportFormat.HTML: "html",
            ExportFormat.PDF: "pdf",
            ExportFormat.JSON: "json",
            ExportFormat.TXT: "txt",
        }

        return f"{slug}.{extensions[format]}"

    @staticmethod
    def get_content_type(format: ExportFormat) -> str:
        """Get the MIME content type for a format.

        Args:
            format: Export format

        Returns:
            MIME content type
        """
        content_types = {
            ExportFormat.MARKDOWN: "text/markdown",
            ExportFormat.HTML: "text/html",
            ExportFormat.PDF: "application/pdf",
            ExportFormat.JSON: "application/json",
            ExportFormat.TXT: "text/plain",
        }
        return content_types[format]

    @staticmethod
    def _to_markdown(content: ContentResponse) -> bytes:
        """Convert content to Markdown format.

        Args:
            content: Content response

        Returns:
            Markdown content as bytes
        """
        lines = []

        # Add metadata header
        lines.append("---")
        lines.append(f"topic: {content.request.topic}")
        lines.append(f"type: {content.request.content_type.value}")
        lines.append(f"created: {content.created_at.isoformat()}")
        if content.request.keywords:
            lines.append(f"keywords: {', '.join(content.request.keywords)}")
        lines.append("---")
        lines.append("")

        # Add title from outline if available
        if content.outline and content.outline.title:
            lines.append(f"# {content.outline.title}")
            lines.append("")

        # Add main content
        if content.content:
            lines.append(content.content)
        else:
            lines.append("*No content generated*")

        lines.append("")

        # Add metadata footer
        lines.append("---")
        lines.append("")
        lines.append(
            f"*Generated by Content Mate on {content.created_at.strftime('%Y-%m-%d %H:%M')} UTC*"
        )

        return "\n".join(lines).encode("utf-8")

    @staticmethod
    def _to_html(content: ContentResponse) -> bytes:
        """Convert content to HTML format.

        Args:
            content: Content response

        Returns:
            HTML content as bytes
        """
        title = content.outline.title if content.outline else content.request.topic
        safe_title = html.escape(title)

        # Convert markdown content to basic HTML
        html_content = ExportService._markdown_to_html(content.content or "")

        html_doc = f"""<!DOCTYPE html>
<html lang="{content.request.language}">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{safe_title}</title>
    <meta name="generator" content="Content Mate">
    <meta name="created" content="{content.created_at.isoformat()}">
    {ExportService._generate_meta_tags(content)}
    <style>
        body {{
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
            padding: 2rem;
            color: #333;
        }}
        h1 {{ color: #1a1a1a; border-bottom: 2px solid #eee; padding-bottom: 0.5rem; }}
        h2 {{ color: #2c2c2c; margin-top: 2rem; }}
        h3 {{ color: #3c3c3c; }}
        p {{ margin: 1rem 0; }}
        blockquote {{
            border-left: 4px solid #ddd;
            margin: 1rem 0;
            padding: 0.5rem 1rem;
            background: #f9f9f9;
        }}
        code {{
            background: #f4f4f4;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-size: 0.9em;
        }}
        pre {{
            background: #f4f4f4;
            padding: 1rem;
            border-radius: 5px;
            overflow-x: auto;
        }}
        ul, ol {{ margin: 1rem 0; padding-left: 2rem; }}
        li {{ margin: 0.5rem 0; }}
        .meta {{
            color: #666;
            font-size: 0.9rem;
            margin-top: 2rem;
            padding-top: 1rem;
            border-top: 1px solid #eee;
        }}
    </style>
</head>
<body>
    <article>
        <h1>{safe_title}</h1>
        {html_content}
    </article>
    <footer class="meta">
        <p>Generated by Content Mate on {content.created_at.strftime("%Y-%m-%d %H:%M")} UTC</p>
        {f"<p>Target audience: {html.escape(content.request.target_audience)}</p>" if content.request.target_audience else ""}
        {f"<p>Keywords: {html.escape(", ".join(content.request.keywords))}</p>" if content.request.keywords else ""}
    </footer>
</body>
</html>"""

        return html_doc.encode("utf-8")

    @staticmethod
    def _to_pdf(content: ContentResponse) -> bytes:
        """Convert content to PDF format.

        Note: This uses a simple HTML-to-PDF approach. For production,
        consider using a proper PDF library like weasyprint or reportlab.

        Args:
            content: Content response

        Returns:
            PDF content as bytes
        """
        # For now, return HTML with PDF-specific styles
        # In production, use weasyprint: weasyprint.HTML(string=html).write_pdf()
        logger.warning("PDF export requires weasyprint. Returning HTML with PDF styles.")

        title = content.outline.title if content.outline else content.request.topic
        safe_title = html.escape(title)
        html_content = ExportService._markdown_to_html(content.content or "")

        # Create a print-friendly HTML that can be saved as PDF
        html_doc = f"""<!DOCTYPE html>
<html lang="{content.request.language}">
<head>
    <meta charset="UTF-8">
    <title>{safe_title}</title>
    <style>
        @page {{
            size: A4;
            margin: 2cm;
        }}
        body {{
            font-family: Georgia, 'Times New Roman', serif;
            font-size: 12pt;
            line-height: 1.6;
            color: #000;
        }}
        h1 {{
            font-size: 24pt;
            margin-bottom: 1cm;
            border-bottom: 1pt solid #000;
            padding-bottom: 0.5cm;
        }}
        h2 {{ font-size: 18pt; margin-top: 1cm; }}
        h3 {{ font-size: 14pt; }}
        p {{ margin: 0.5cm 0; text-align: justify; }}
        blockquote {{
            margin: 0.5cm 1cm;
            padding-left: 0.5cm;
            border-left: 2pt solid #666;
            font-style: italic;
        }}
        .footer {{
            margin-top: 1cm;
            padding-top: 0.5cm;
            border-top: 1pt solid #ccc;
            font-size: 10pt;
            color: #666;
        }}
        @media print {{
            body {{ margin: 0; }}
            .no-print {{ display: none; }}
        }}
    </style>
</head>
<body>
    <h1>{safe_title}</h1>
    {html_content}
    <div class="footer">
        <p>Generated by Content Mate | {content.created_at.strftime("%Y-%m-%d")}</p>
    </div>
</body>
</html>"""

        return html_doc.encode("utf-8")

    @staticmethod
    def _to_json(content: ContentResponse) -> bytes:
        """Export content as JSON.

        Args:
            content: Content response

        Returns:
            JSON content as bytes
        """
        import json

        data = {
            "id": content.id,
            "status": content.status.value,
            "request": {
                "topic": content.request.topic,
                "content_type": content.request.content_type.value,
                "target_audience": content.request.target_audience,
                "tone": content.request.tone,
                "language": content.request.language,
                "word_count": content.request.word_count,
                "keywords": content.request.keywords,
            },
            "content": content.content,
            "outline": None,
            "research": None,
            "metadata": {
                "created_at": content.created_at.isoformat(),
                "completed_at": content.completed_at.isoformat() if content.completed_at else None,
                "processing_time_seconds": content.processing_time_seconds,
            },
        }

        if content.outline:
            data["outline"] = {
                "title": content.outline.title,
                "hook": content.outline.hook,
                "sections": content.outline.sections,
                "conclusion_points": content.outline.conclusion_points,
                "cta": content.outline.cta,
            }

        if content.research:
            data["research"] = {
                "key_facts": content.research.key_facts,
                "statistics": content.research.statistics,
                "quotes": content.research.quotes,
                "competitor_insights": content.research.competitor_insights,
            }

        return json.dumps(data, indent=2, ensure_ascii=False).encode("utf-8")

    @staticmethod
    def _to_txt(content: ContentResponse) -> bytes:
        """Export content as plain text.

        Args:
            content: Content response

        Returns:
            Plain text content as bytes
        """
        lines = []

        # Add title
        title = content.outline.title if content.outline else content.request.topic
        lines.append(title.upper())
        lines.append("=" * len(title))
        lines.append("")

        # Add content (strip markdown)
        if content.content:
            plain_text = ExportService._strip_markdown(content.content)
            lines.append(plain_text)
        else:
            lines.append("(No content generated)")

        lines.append("")
        lines.append("-" * 40)
        lines.append("Generated by Content Mate")
        lines.append(f"Date: {content.created_at.strftime('%Y-%m-%d %H:%M')} UTC")

        return "\n".join(lines).encode("utf-8")

    @staticmethod
    def _markdown_to_html(markdown: str) -> str:
        """Convert basic Markdown to HTML.

        A simple converter for common Markdown elements.
        For production, consider using markdown2 or mistune.

        Args:
            markdown: Markdown text

        Returns:
            HTML string
        """
        if not markdown:
            return "<p><em>No content</em></p>"

        text = markdown

        # Escape HTML entities first
        text = html.escape(text)

        # Headers
        text = re.sub(r"^### (.+)$", r"<h3>\1</h3>", text, flags=re.MULTILINE)
        text = re.sub(r"^## (.+)$", r"<h2>\1</h2>", text, flags=re.MULTILINE)
        text = re.sub(r"^# (.+)$", r"<h1>\1</h1>", text, flags=re.MULTILINE)

        # Bold and italic
        text = re.sub(r"\*\*(.+?)\*\*", r"<strong>\1</strong>", text)
        text = re.sub(r"\*(.+?)\*", r"<em>\1</em>", text)

        # Code blocks
        text = re.sub(r"```(\w*)\n(.*?)```", r"<pre><code>\2</code></pre>", text, flags=re.DOTALL)
        text = re.sub(r"`(.+?)`", r"<code>\1</code>", text)

        # Blockquotes
        text = re.sub(r"^> (.+)$", r"<blockquote>\1</blockquote>", text, flags=re.MULTILINE)

        # Lists
        text = re.sub(r"^- (.+)$", r"<li>\1</li>", text, flags=re.MULTILINE)
        text = re.sub(r"^(\d+)\. (.+)$", r"<li>\2</li>", text, flags=re.MULTILINE)

        # Wrap consecutive li elements in ul/ol
        text = re.sub(r"(<li>.*?</li>\n?)+", lambda m: f"<ul>{m.group(0)}</ul>", text)

        # Paragraphs (double newlines)
        paragraphs = text.split("\n\n")
        processed = []
        for p in paragraphs:
            p = p.strip()
            if p and not p.startswith("<"):
                p = f"<p>{p}</p>"
            processed.append(p)
        text = "\n".join(processed)

        # Clean up single newlines within paragraphs
        text = re.sub(r"(?<!</p>)\n(?!<)", " ", text)

        return text

    @staticmethod
    def _strip_markdown(markdown: str) -> str:
        """Strip Markdown formatting to get plain text.

        Args:
            markdown: Markdown text

        Returns:
            Plain text
        """
        text = markdown

        # Remove headers markers
        text = re.sub(r"^#{1,6}\s+", "", text, flags=re.MULTILINE)

        # Remove bold/italic
        text = re.sub(r"\*\*(.+?)\*\*", r"\1", text)
        text = re.sub(r"\*(.+?)\*", r"\1", text)

        # Remove code blocks
        text = re.sub(r"```.*?```", "", text, flags=re.DOTALL)
        text = re.sub(r"`(.+?)`", r"\1", text)

        # Remove blockquote markers
        text = re.sub(r"^>\s*", "", text, flags=re.MULTILINE)

        # Remove list markers
        text = re.sub(r"^[-*]\s+", "", text, flags=re.MULTILINE)
        text = re.sub(r"^\d+\.\s+", "", text, flags=re.MULTILINE)

        # Remove links but keep text
        text = re.sub(r"\[(.+?)\]\(.+?\)", r"\1", text)

        # Remove images
        text = re.sub(r"!\[.*?\]\(.+?\)", "", text)

        # Clean up extra whitespace
        text = re.sub(r"\n{3,}", "\n\n", text)

        return text.strip()

    @staticmethod
    def _generate_meta_tags(content: ContentResponse) -> str:
        """Generate HTML meta tags for SEO.

        Args:
            content: Content response

        Returns:
            HTML meta tags string
        """
        tags = []

        if content.request.target_audience:
            tags.append(
                f'<meta name="target-audience" content="{html.escape(content.request.target_audience)}">'
            )

        if content.request.keywords:
            keywords = ", ".join(content.request.keywords)
            tags.append(f'<meta name="keywords" content="{html.escape(keywords)}">')

        # Add Open Graph tags
        title = content.outline.title if content.outline else content.request.topic
        tags.append(f'<meta property="og:title" content="{html.escape(title)}">')
        tags.append('<meta property="og:type" content="article">')

        if content.content:
            description = content.content[:160].replace("\n", " ")
            tags.append(f'<meta name="description" content="{html.escape(description)}">')
            tags.append(f'<meta property="og:description" content="{html.escape(description)}">')

        return "\n    ".join(tags)
